package org.wyona.yanel.impl.resources.jellyadapterofcmdv3;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.avalon.framework.configuration.Configuration;
import org.apache.avalon.framework.configuration.ConfigurationUtil;
import org.apache.commons.jelly.JellyContext;
import org.apache.commons.jelly.XMLOutput;
import org.apache.xml.resolver.tools.CatalogResolver;
import org.apache.xml.serializer.Serializer;
import org.w3c.dom.Document;
import org.wyona.security.core.api.Identity;
import org.wyona.yanel.core.Constants;
import org.wyona.yanel.core.attributes.viewable.View;
import org.wyona.yanel.core.serialization.SerializerFactory;
import org.wyona.yanel.core.source.SourceResolver;
import org.wyona.yanel.core.transformation.I18nTransformer3;
import org.wyona.yanel.core.transformation.XIncludeTransformer;
import org.wyona.yanel.core.util.PathUtil;
import org.wyona.yanel.impl.resources.jellyadapterofcmdv3.ViewDescriptorUsingTemplate.TemplateOption;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

/**
 * This resource type takes care only of the custom configuration.
 * It behaves much like org.wyona.yanel.impl.resources.usecase.UsecaseResource.
 * In the resource configuration one can specify views and there a Jelly template and arbitrary XSLTs.
 * <p>
 * The templates get the following parameters(subclasses may enrich this set):
 * <ul>
 * <li> <b>All the parameters from the incoming request</b>
 * <li>yanel.path.name
 * <li>yanel.path
 * <li>yanel.back2realm
 * <li>yanel.back2context
 * <li>yanel.global.htdocs
 * <li>yanel.resource.htdocs
 * <li>yanel.requested.language
 * <li>yanel.content.language
 * <li>client (i.e. user agent)
 * <li>yanel.username
 * <li>yanel.toolbar.status
 * <li>yanel.reserved.prefix
 * </ul>
 * <p>
 * The view description looks as follows:
 * <pre>
 * [yanel:custom-config]
 *   [views xmlns="http://www.wyona.org/yanel/rti/1.0"]
 *     [view id="..."]
 *       [template type="JELLY"]...[/template]
 *       [xslt]...[/xslt]*
 *       [mime-type]...[/mime-type]? (e.g. text/html)
 *       [serializer key="..."/]?
 *     [/view]
 *     [screen/]*
 *     ...
 *     [fragment/]*
 * [/yanel:custom-config]
 * </pre>
 * The 'fragment' view hints the view adapters that this is not the user screen but rather a fragment generated by AJAX call or something similar.
 * The 'screen' view is the synonym of 'view', used to stress that the view is not a fragment
 * */
public abstract class JellyControllerAdapter extends ControllerAdapter {
    
    private static Logger log = LogManager.getLogger(JellyControllerAdapter.class);

    // Jelly can be configured to escape the text that it gets from JAVA
    // This parameter allows to disable escaping.
    // Accepted values: on, off, true, false, yes, no
    public static final String ESCAPE_TEXT_IN_JELLY = "escape.text.in.jelly";
    
    private HashMap<String, ViewDescriptorUsingTemplate> viewDescriptors;
    
    public JellyControllerAdapter() {
        super();
    }
    
    /**
     * Checks if the parameter that configures the escaping was passed:
     * <ul>
     * <li> As a parameter in the request
     * <li> As a property in the configuration
     * </ul>
     * @return <code>true</code> by default, otherwise depends on the parameter value
     * */
    public boolean isEscapeTextEnabled(){
        String escape = getParameterAsString(ESCAPE_TEXT_IN_JELLY);
        if(escape == null){
            try {
                escape = getConfiguration().getProperty(ESCAPE_TEXT_IN_JELLY);
            } catch (Exception e) {
                log.info("Could not detect the property "+ESCAPE_TEXT_IN_JELLY+", will use default value");
            }
        }
        
        if(escape == null){
            return true;
        }
		if("on".equals(escape.trim().toLowerCase()) || "yes".equals(escape.trim().toLowerCase()) || Boolean.valueOf(escape.trim())){
		    return true;
		}
		return false;
    }
    
    /**
     *
     */
    public ViewDescriptorUsingTemplate[] getViewDescriptors() {
        if (this.viewDescriptors == null) {
            try {
                this.viewDescriptors = new HashMap<String, ViewDescriptorUsingTemplate>();
                
                // reads views from configuration:
                if (getConfiguration() != null && getConfiguration().getCustomConfiguration() != null) {
                    Document customConfigDoc = getConfiguration().getCustomConfiguration();
                    Configuration config = ConfigurationUtil.toConfiguration(customConfigDoc.getDocumentElement());
                    Configuration viewsConfig = config.getChild("views");

                    {
                        ViewDescriptorUsingTemplate defaultView = null;
                        
                        // Collect view definitions
                        Configuration[] viewConfigs = viewsConfig.getChildren("view");
                        for (int i = 0; i < viewConfigs.length; i++) {
                            String id = normalize(viewConfigs[i].getAttribute("id"));
                            
                            ViewDescriptorUsingTemplate viewDescriptor = new ViewDescriptorUsingTemplate(id, viewConfigs[i]);
                            
                            if(Constants.Request.DEFAULT_VIEW_ID.equals(id)){
                                defaultView = viewDescriptor;
                            }
                            
                            this.viewDescriptors.put(id, viewDescriptor);
                        }
                        
                        if(defaultView == null){
                            defaultView = new ViewDescriptorUsingTemplate(Constants.Request.DEFAULT_VIEW_ID);
                            defaultView.setMimeType("application/xml");
                            this.viewDescriptors.put(Constants.Request.DEFAULT_VIEW_ID, defaultView);
                        }
                    }
                    
                    {
                        // Collect fragment definitions
                        //log.debug("Get all fragments ...");
                        Configuration[] fragmentConfigs = viewsConfig.getChildren("fragment");
                        for (int i = 0; i < fragmentConfigs.length; i++) {
                            String id = normalize(fragmentConfigs[i].getAttribute("id"));
                            if(log.isDebugEnabled()) log.debug("Fragment ID: " + id);
                            
                            ViewDescriptorUsingTemplate viewDescriptor = new ViewDescriptorUsingTemplate(id, fragmentConfigs[i], true);
                            if(this.viewDescriptors.keySet().contains(id)){
                                log.warn("The view with ID '" + id + "' will be ignored as the descriptor with such an ID already exists!");
                            }else{
                                this.viewDescriptors.put(id, viewDescriptor);
                            }
                        }
                    }
                }
            } catch (Exception e) {
                throw new IllegalArgumentException("Views are not properly configured");
            }
        }
        
        return this.viewDescriptors.values().toArray(new ViewDescriptorUsingTemplate[this.viewDescriptors.size()]);
    }
    
    /**
     * Runs the pipeline of templates. You can feed an XML, JELLY or XSLT to the pipe.
     * Every template will be processed and passed through internationalization and XInclude transformers.
     * So every subsequent template can react to the expanded(resolved) input.
     */
    public View getView(String viewId) throws Exception {
        View view = new View();
        
        viewId = normalize(viewId);
        
        ViewDescriptorUsingTemplate viewDescriptor = (ViewDescriptorUsingTemplate)getViewDescriptor(viewId);
        view.setMimeType(viewDescriptor.getMimeType());
        
        try {
            Serializer serializer = viewDescriptor.getSerializer();
            Serializer xmlSerializer = SerializerFactory.getSerializer(SerializerFactory.XML);
            
            InputStream content = null;
            
            TemplateOption [] templates = viewDescriptor.getTemplates();
            //TODO: don't serialize on each template, rather pipe content handlers
            for (int i = 0; i < templates.length; i++) {
                // The first one is JELLY or XML, then every other is XSLT
                if(i + 1 == templates.length){
                    // Use configured serializer for the last template only
                    content = processTemplate(content, templates[i], serializer);
                }else{
                    // In the intermediate steps only XML is produced
                    content = processTemplate(content, templates[i], xmlSerializer);
                }
            }
            
            // write result into view:
            view.setInputStream(content);
        } catch(Exception e) {
            log.error(e + " (" + getPath() + ", " + getRealm() + ")", e);
            throw new Exception(e);
        }
        
        return view;
    }
    
    /**
     * @param content Template may be applied to it, e.g. for transformations
     * @param template Template
     * @param serializer Serializer
     * 
     * @return result of the processing as a stream
     */
    protected InputStream processTemplate(InputStream content, TemplateOption template, Serializer serializer) throws Exception{
        InputStream result = null;
        
        SourceResolver uriResolver = new SourceResolver(this);
        CatalogResolver catalogResolver = new CatalogResolver();
        
        InputStream templateInputStream = getTemplateAsStream(template);
        
        if(TemplateOption.TYPE_XSLT.equals(template.getType())){
            // Here after the required template it is 
            
            // create xslt transformer:
            SAXTransformerFactory tf = (SAXTransformerFactory)TransformerFactory.newInstance();
            tf.setURIResolver(uriResolver);
            
            // attach handler:
            TransformerHandler th = tf.newTransformerHandler(new StreamSource(templateInputStream));
            
            th.getTransformer().setURIResolver(uriResolver);
            Transformer transformer = th.getTransformer();
            
            passParameters(transformer);
            
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            serializer.setOutputStream(baos);
            th.setResult(new SAXResult(serializer.asContentHandler()));

            // create reader:
            XMLReader xmlReader = XMLReaderFactory.createXMLReader();
            xmlReader.setEntityResolver(catalogResolver);
            xmlReader.setFeature("http://xml.org/sax/features/namespace-prefixes", true);
            xmlReader.setProperty("http://xml.org/sax/properties/lexical-handler", th);
            xmlReader.setContentHandler(th);
            
            // execute:
            xmlReader.parse(new InputSource(content));
            
            result = new ByteArrayInputStream(baos.toByteArray());
        }else if(TemplateOption.TYPE_JELLY.equals(template.getType())){
            log.debug("Template type: " + template.getType());
            JellyContext jellyContext = new JellyContext();
            passParameters(jellyContext);

            ByteArrayOutputStream jellyResultStream = new ByteArrayOutputStream();
            
            XMLOutput jellyOutput = XMLOutput.createXMLOutput(jellyResultStream, isEscapeTextEnabled());
            jellyContext.runScript(new InputSource(templateInputStream), jellyOutput);
            jellyOutput.flush();
            result = new ByteArrayInputStream(jellyResultStream.toByteArray());
        }else{
            result = templateInputStream;
        }
        
        //
        // Pass the result through i18n and XInclude transformers
        //

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        serializer.setOutputStream(baos);
        
        // create i18n transformer:
        I18nTransformer3 i18nTransformer = new I18nTransformer3(getI18NCatalogueNames(), getRequestedLanguage(), getUserLanguage(), getRealm().getDefaultLanguage(), uriResolver);
        i18nTransformer.setEntityResolver(catalogResolver);


        // create xinclude transformer:
        XIncludeTransformer xIncludeTransformer = new XIncludeTransformer();
        xIncludeTransformer.setResolver(uriResolver);
        
        // chain everything together (create a pipeline):
        xIncludeTransformer.setResult(new SAXResult(i18nTransformer));
        i18nTransformer.setResult(new SAXResult(serializer.asContentHandler()));
        
        // create reader and execute
        XMLReader xmlReader = XMLReaderFactory.createXMLReader();
        xmlReader.setEntityResolver(catalogResolver);
        xmlReader.setFeature("http://xml.org/sax/features/namespace-prefixes", true);
        
        xmlReader.setContentHandler(new SAXResult(xIncludeTransformer).getHandler());
        xmlReader.setProperty("http://xml.org/sax/properties/lexical-handler", xIncludeTransformer);
        
        xmlReader.setContentHandler(new SAXResult(i18nTransformer).getHandler());
        xmlReader.parse(new InputSource(result));
        
        result = new ByteArrayInputStream(baos.toByteArray());
        
        return result;
    }
    
    /**
     * Tries to get the template as input stream. The template can be either accessible through 
     * a URL or simply from the repository. 
     *
     * @param template TemplateOption containing type and URL
     */
    protected InputStream getTemplateAsStream(TemplateOption template)throws Exception{
        log.debug("Template: " + template.getUrl());
        InputStream templateInputStream = null;
        if(!template.getUrl().startsWith("/")){
            // Resolve the URI into the InputStream
            Source src = new SourceResolver(this).resolve(template.getUrl(), null);
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            TransformerFactory.newInstance().newTransformer().transform(src, new StreamResult(bos));
            templateInputStream = new ByteArrayInputStream(bos.toByteArray());
        }else{
            // Just take the template from the repository node
            templateInputStream = getRealm().getRepository().getNode(template.getUrl()).getInputStream();
        }
        return templateInputStream;
    }
    
    /**
     * Pass parameters to Jelly context (Add more parameters in subclasses if needed)
     */
    protected void passParameters(JellyContext jellyContext) throws Exception{
        // Attach all parameters that came with the request, such that templates can make use of them.
        // NOTE: all parameter values will be of type String. In XSLT: <param name="p" value="'actual_value'"/>
        for (Iterator i = getParameters().entrySet().iterator(); i.hasNext();) {
            Map.Entry entry = (Map.Entry) i.next();
            log.debug("Add entry to jelly context: " + entry.getKey());
            jellyContext.setVariable(String.valueOf(entry.getKey()), entry.getValue());
        }
        
        // Set general parameters
        jellyContext.setVariable("resource", this); // TODO: Somehow this doesn't work!

        jellyContext.setVariable("continuation.id", getContinuation().getId());
        jellyContext.setVariable("continuation.id.key", YANEL_CONTINUATION_ID);

        jellyContext.setVariable("yanel.path.name", org.wyona.commons.io.PathUtil.getName(getPath()));
        jellyContext.setVariable("yanel.path", getPath());
        
        jellyContext.setVariable("yanel.back2realm", PathUtil.backToRealm(getPath()));
        jellyContext.setVariable("yanel.back2context", PathUtil.backToContext(realm, getPath()));
        
        jellyContext.setVariable("yanel.global.htdocs", PathUtil.getGlobalHtdocsPath(this));
        jellyContext.setVariable("yanel.resource.htdocs", PathUtil.getResourcesHtdocsPath(this));
        
        jellyContext.setVariable("yanel.requested.language", getRequestedLanguage());
        jellyContext.setVariable("yanel.content.language", getContentLanguage());
        
        String userAgent = getEnvironment().getRequest().getHeader("User-Agent");
        String client = getClient(userAgent);
        if (client != null) jellyContext.setVariable("client", client);

        // username
        String username = getUsername();
        if (username != null) jellyContext.setVariable("yanel.username", username);

        // Add toolbar status
        String toolbarStatus = getToolbarStatus();
        if (toolbarStatus != null) jellyContext.setVariable("yanel.toolbar.status", toolbarStatus);
        
        jellyContext.setVariable("yanel.reserved.prefix", getYanel().getReservedPrefix());
    }
    
    /**
     * Add more parameters in subclasses if needed
     * */
    protected void passParameters(Transformer transformer) throws Exception{
        // Attach all parameters that came with the request. Templates can make use of them.
        // NOTE: all parameter values will be of type String. In XSLT: <param name="p" value="'actual_value'"/>
        for (Iterator i = getParameters().entrySet().iterator(); i.hasNext();) {
            Map.Entry entry = (Map.Entry) i.next();
            if (entry.getValue() instanceof String) {
                String value = (String) entry.getValue();
                transformer.setParameter(String.valueOf(entry.getKey()), value);
            } else if(entry.getValue() instanceof String[]){
                // values separated by a space
                String separator = " ";
                
                StringBuffer finalValue = new StringBuffer();
                String [] values = (String[]) entry.getValue();
                for (int j = 0; j < values.length; j++) {
                    finalValue.append(values[j]);
                    if(j + 1 != values.length){
                        finalValue.append(separator);
                    }
                }
                transformer.setParameter(String.valueOf(entry.getKey()), finalValue);
            } else{
                // Never happens
            }
        }
        
        // Set general parameters
        transformer.setParameter("yanel.path.name", org.wyona.commons.io.PathUtil.getName(getPath()));
        transformer.setParameter("yanel.path", getPath());
        
        transformer.setParameter("yanel.back2realm", PathUtil.backToRealm(getPath()));
        transformer.setParameter("yanel.back2context", PathUtil.backToContext(realm, getPath()));
        
        transformer.setParameter("yanel.global.htdocs", PathUtil.getGlobalHtdocsPath(this));
        transformer.setParameter("yanel.resource.htdocs", PathUtil.getResourcesHtdocsPath(this));
        
        transformer.setParameter("yanel.requested.language", getRequestedLanguage());
        transformer.setParameter("yanel.content.language", getContentLanguage());
        
        String userAgent = getEnvironment().getRequest().getHeader("User-Agent");
        String client = getClient(userAgent);
        if (client != null) transformer.setParameter("client", client);

        // username
        String username = getUsername();
        if (username != null) transformer.setParameter("yanel.username", username);

        // Add toolbar status
        String toolbarStatus = getToolbarStatus();
        if (toolbarStatus != null) transformer.setParameter("yanel.toolbar.status", toolbarStatus);
        
        transformer.setParameter("yanel.reserved.prefix", getYanel().getReservedPrefix());
    }
    
    protected final String getUsername() {
        Identity identity = getEnvironment().getIdentity();
        if (identity != null) return identity.getUsername();
        return null;
    }

    /**
     * Get simplified user agent
     */
    protected final String getClient(String userAgent) {
        if (userAgent != null && userAgent.indexOf("Firefox") > 0) {
            return "firefox";
        } else if (userAgent != null && userAgent.indexOf("MSIE") > 0) {
            return "msie";
        } else {
            log.warn("Client could not be recognized: " + userAgent);
            return null;
        }
    }

    /**
     *
     */
    protected final String getToolbarStatus() {
        // TODO: Use YanelServlet.TOOLBAR_KEY instead "toolbar"!
        return (String) getEnvironment().getRequest().getSession(true).getAttribute("toolbar");
    }

    /**
     * Get user language (order: profile, browser, ...)
     */
    private String getUserLanguage() throws Exception {
        Identity identity = getEnvironment().getIdentity();
        String language = getRequestedLanguage();
        String userID = identity.getUsername();
        if (userID != null) {
            String userLanguage = getRealm().getIdentityManager().getUserManager().getUser(userID).getLanguage();
            if(userLanguage != null) {
                language = userLanguage;
                log.debug("Use user profile language: " + language);
            } else {
                log.warn("Use requested language: " + language);
            }
        }
        return language;
    }
}
